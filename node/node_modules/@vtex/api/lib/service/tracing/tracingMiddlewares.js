"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const opentracing_1 = require("opentracing");
const stream_1 = require("stream");
const constants_1 = require("../../constants");
const tracing_1 = require("../../tracing");
const Tags_1 = require("../../tracing/Tags");
const utils_1 = require("../../tracing/utils");
const utils_2 = require("../../utils");
const instruments_1 = require("./metrics/instruments");
const PATHS_BLACKLISTED_FOR_TRACING = ['/metrics', '/_status', '/healthcheck'];
exports.addTracingMiddleware = (tracer) => {
    const concurrentRequests = instruments_1.createConcurrentRequestsInstrument();
    const requestTimings = instruments_1.createRequestsTimingsInstrument();
    const totalRequests = instruments_1.createTotalRequestsInstrument();
    const responseSizes = instruments_1.createRequestsResponseSizesInstrument();
    const abortedRequests = instruments_1.createTotalAbortedRequestsInstrument();
    return async function addTracing(ctx, next) {
        var _a;
        const start = process.hrtime();
        concurrentRequests.inc(1);
        if (PATHS_BLACKLISTED_FOR_TRACING.includes(ctx.request.path)) {
            await next();
            concurrentRequests.dec(1);
            return;
        }
        const rootSpan = tracer.extract(opentracing_1.FORMAT_HTTP_HEADERS, ctx.request.headers);
        const currentSpan = tracer.startSpan('unknown-operation', {
            childOf: rootSpan,
            tags: { [Tags_1.OpentracingTags.SPAN_KIND]: Tags_1.OpentracingTags.SPAN_KIND_RPC_SERVER },
        });
        const initialSamplingDecision = tracing_1.getTraceInfo(currentSpan).isSampled;
        ctx.tracing = { currentSpan, tracer };
        ctx.req.once('aborted', () => abortedRequests.inc({ ["handler" /* REQUEST_HANDLER */]: currentSpan.operationName }, 1));
        let responseClosed = false;
        ctx.res.once('close', () => (responseClosed = true));
        try {
            await next();
        }
        catch (err) {
            tracing_1.ErrorReport.create({ originalError: err }).injectOnSpan(currentSpan, (_a = ctx.vtex) === null || _a === void 0 ? void 0 : _a.logger);
            throw err;
        }
        finally {
            const responseLength = ctx.response.length;
            if (responseLength) {
                responseSizes.observe({ ["handler" /* REQUEST_HANDLER */]: currentSpan.operationName }, responseLength);
            }
            totalRequests.inc({
                ["handler" /* REQUEST_HANDLER */]: currentSpan.operationName,
                ["status_code" /* STATUS_CODE */]: ctx.response.status,
            }, 1);
            const traceInfo = tracing_1.getTraceInfo(currentSpan);
            if (traceInfo.isSampled) {
                if (!initialSamplingDecision) {
                    currentSpan.setTag(Tags_1.OpentracingTags.SPAN_KIND, Tags_1.OpentracingTags.SPAN_KIND_RPC_SERVER);
                }
                currentSpan.addTags({
                    [Tags_1.OpentracingTags.HTTP_URL]: ctx.request.href,
                    [Tags_1.OpentracingTags.HTTP_METHOD]: ctx.request.method,
                    [Tags_1.OpentracingTags.HTTP_STATUS_CODE]: ctx.response.status,
                    ["http.path" /* HTTP_PATH */]: ctx.request.path,
                    ["vtex.request_id" /* VTEX_REQUEST_ID */]: ctx.get(constants_1.REQUEST_ID_HEADER),
                    ["vtex.incoming.workspace" /* VTEX_WORKSPACE */]: ctx.get(constants_1.WORKSPACE_HEADER),
                    ["vtex.incoming.account" /* VTEX_ACCOUNT */]: ctx.get(constants_1.ACCOUNT_HEADER),
                });
                currentSpan.log(utils_1.cloneAndSanitizeHeaders(ctx.request.headers, 'req.headers.'));
                currentSpan.log(utils_1.cloneAndSanitizeHeaders(ctx.response.headers, 'res.headers.'));
                ctx.set(constants_1.TRACE_ID_HEADER, traceInfo.traceId);
            }
            const onResFinished = () => {
                requestTimings.observe({
                    ["handler" /* REQUEST_HANDLER */]: currentSpan.operationName,
                }, utils_2.hrToMillisFloat(process.hrtime(start)));
                concurrentRequests.dec(1);
                currentSpan.finish();
            };
            if (responseClosed) {
                onResFinished();
            }
            else {
                stream_1.finished(ctx.res, onResFinished);
            }
        }
    };
};
exports.nameSpanOperationMiddleware = (operationType, operationName) => {
    return function nameSpanOperation(ctx, next) {
        var _a;
        (_a = ctx.tracing) === null || _a === void 0 ? void 0 : _a.currentSpan.setOperationName(`${operationType}:${operationName}`);
        return next();
    };
};
exports.traceUserLandRemainingPipelineMiddleware = () => {
    return async function traceUserLandRemainingPipeline(ctx, next) {
        const tracingCtx = ctx.tracing;
        ctx.tracing = undefined;
        const span = tracingCtx.currentSpan;
        const userLandTracer = ctx.vtex.tracer;
        userLandTracer.setFallbackSpan(span);
        userLandTracer.lockFallbackSpan();
        const startTime = process.hrtime();
        try {
            span.log({ event: "user-middlewares-start" /* USER_MIDDLEWARES_START */ });
            await next();
        }
        catch (err) {
            tracing_1.ErrorReport.create({ originalError: err }).injectOnSpan(span, ctx.vtex.logger);
            throw err;
        }
        finally {
            span.log({
                event: "user-middlewares-finish" /* USER_MIDDLEWARES_FINISH */,
                ["user-middlewares-duration" /* USER_MIDDLEWARES_DURATION */]: utils_2.hrToMillis(process.hrtime(startTime)),
            });
            ctx.tracing = tracingCtx;
        }
    };
};
